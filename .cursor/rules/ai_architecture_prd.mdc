---
alwaysApply: true
---

# Aldi Meal Planner 2.0 – AI-Powered Architecture PRD

## Overview

Aldi Meal Planner 2.0 is an AI-native web application that uses LangChain.js and Google Gemini to intelligently generate weekly meal plans and grocery lists. By leveraging Large Language Models (LLMs) for complex reasoning instead of brittle algorithmic code, the system adapts to user preferences, budget constraints, and variety requirements with minimal manual programming.

**Core Philosophy:** Let AI handle the complexity. Replace fragile if/else logic with intelligent reasoning that adapts to edge cases and new constraints automatically.

## Technical Stack

- **Frontend:** React 19, React Router 7, Tailwind CSS, Vite
- **Backend:** Express.js, Node.js (ES modules)
- **Database:** Supabase (PostgreSQL) with Row-Level Security (RLS)
- **AI Framework:** LangChain.js v0.3+
- **LLM:** Google Generative AI (Gemini 1.5 Pro)
- **Auth:** Supabase Auth (Google OAuth)

## Goals

1. **Intelligent Meal Planning** - Use AI to reason about multi-dimensional constraints (budget, variety, nutrition, user preferences, past meals)
2. **Reduce Maintenance Burden** - Replace hundreds of lines of brittle algorithm code with prompt-based AI agents
3. **Adaptive System** - Add new constraints or preferences by updating prompts, not rewriting code
4. **Explainability** - AI provides reasoning for each decision (why recipes were chosen, how budget was optimized)
5. **Self-Improving** - System learns from user feedback (ratings, swaps) to improve future suggestions

## Target Audience

Same as original PRD:
- Budget-conscious individuals and families
- People with ADHD or limited executive function
- Aldi shoppers seeking structured, low-effort meal planning

## AI-Powered Features

### 1. Meal Plan Generation Agent

**Purpose:** Generate 7-day meal plans that satisfy complex, multi-dimensional constraints.

**Capabilities:**
- Reasons about budget allocation across the week
- Enforces protein variety (avoid repetition)
- Considers user dietary preferences and dislikes
- Avoids recipes used in past 4 weeks
- Prioritizes pantry items with expiration dates
- Explains reasoning for each recipe selection

**Implementation:** LangChain StructuredOutputParser with Zod schema validation

**Inputs:**
- Weekly budget (number)
- User preferences (dietary tags, liked/disliked ingredients)
- Available recipes (from Supabase with cost, category metadata)
- Past 4 weeks of meal plans (to avoid repetition)
- Must-use pantry items (expiring soon)

**Output:** Structured JSON with:
```typescript
{
  meals: Array<{
    day: string,
    recipe_id: string,
    recipe_name: string,
    estimated_cost: number,
    category: string,
    reasoning: string // "Chose chicken stir-fry because user hasn't had chicken in 5 days and it fits budget"
  }>,
  total_cost: number,
  budget_remaining: number,
  variety_analysis: string // Summary of protein/category distribution
}
```

### 2. Recipe Discovery Agent

**Purpose:** Find or generate new recipes when variety is low or user makes specific requests.

**Capabilities:**
- Search existing recipe library with natural language ("quick vegetarian meals under $5")
- Generate new recipes on-demand that meet cost and ingredient constraints
- Match scraped recipes from external sources to Supabase ingredients
- Suggest recipe swaps during meal planning ("similar recipes with less prep time")

**Implementation:** LangChain Agent with tool calling (can query Supabase or generate new content)

### 3. Grocery List Optimizer Agent

**Purpose:** Intelligently consolidate ingredients across multiple recipes and optimize for Aldi store layout.

**Capabilities:**
- Smart unit conversion ("1 lb ground beef + 8 oz ground beef = 1.5 lb total")
- Consolidate duplicate ingredients across recipes
- Group by store aisle/category
- Identify bulk purchase opportunities
- Flag pantry items the user already has

**Implementation:** LangChain Chain with structured output

### 4. Ingredient Matching Agent

**Purpose:** Resolve ingredient names from scraped recipes to Supabase database entries.

**Capabilities:**
- Fuzzy matching ("ground chuck" → "ground beef 80/20")
- Handles variations ("yellow onion" vs "onion" vs "1 medium onion")
- Suggests creating new ingredients when no match found
- Normalizes units and quantities

**Implementation:** LangChain Chain with vector similarity (future: embeddings)

### 5. Cost Calculation Agent

**Purpose:** Calculate recipe costs with intelligent unit conversion and pricing logic.

**Capabilities:**
- Converts between volume, weight, and count units
- Handles ingredient-specific densities (flour vs water vs rice)
- Rounds up to package quantities
- Identifies missing price data and suggests alternatives
- Explains cost breakdown per ingredient

**Implementation:** LangChain Tool (callable by other agents)

## Architecture

### High-Level Flow

```
User Request → Express API → LangChain Agent → Gemini LLM → Structured Output
                    ↓
                Supabase (read context)
                    ↓
            LangChain Tools (query DB, calculate costs)
                    ↓
            Save results → Supabase
                    ↓
            Return to frontend
```

### Directory Structure

```
backend/
├── ai/
│   ├── agents/
│   │   ├── mealPlanningAgent.js      # Core meal plan generation
│   │   ├── recipeDiscoveryAgent.js   # Find/create recipes
│   │   ├── groceryOptimizerAgent.js  # Smart grocery consolidation
│   │   ├── ingredientMatchingAgent.js # Resolve ingredient names
│   │   └── costCalculatorAgent.js     # Intelligent pricing
│   │
│   ├── chains/
│   │   ├── varietyAnalysisChain.js   # Analyze meal variety
│   │   ├── recipeParserChain.js      # Extract structured data from text
│   │   └── budgetOptimizationChain.js # Maximize value within budget
│   │
│   ├── tools/
│   │   ├── supabaseTool.js           # Query recipes/ingredients as LangChain tool
│   │   ├── pricingTool.js            # Look up current Aldi prices
│   │   └── pantryTool.js             # Check user pantry inventory
│   │
│   ├── prompts/
│   │   ├── mealPlanning.js           # Prompt templates for meal planning
│   │   ├── recipeGeneration.js       # Prompts for creating new recipes
│   │   └── costAnalysis.js           # Prompts for cost optimization
│   │
│   └── memory/
│       └── userPreferencesMemory.js  # Long-term memory of user preferences
│
├── supabase/                          # Keep existing DB clients
│   ├── mealPlanClient.js
│   ├── recipeClient.js
│   ├── pantryClient.js
│   └── ...
│
└── utils/
    └── unitConversions.js             # May still be needed for fallback
```

### Server Routes

```javascript
// server/index.js
import { generateMealPlan } from './backend/ai/agents/mealPlanningAgent.js';
import { discoverRecipes } from './backend/ai/agents/recipeDiscoveryAgent.js';
import { optimizeGroceryList } from './backend/ai/agents/groceryOptimizerAgent.js';

// Generate meal plan (replaces old algorithm)
app.post('/api/meal-plan/generate', async (req, res) => {
  const { userId, weekStart, budget } = req.body;
  const plan = await generateMealPlan({ userId, weekStart, budget });
  res.json({ success: true, plan });
});

// Discover new recipes
app.post('/api/recipes/discover', async (req, res) => {
  const { query, maxCost, category } = req.body;
  const recipes = await discoverRecipes({ query, maxCost, category });
  res.json({ success: true, recipes });
});

// Optimize grocery list
app.post('/api/grocery-list/optimize', async (req, res) => {
  const { mealPlanId, userId } = req.body;
  const groceryList = await optimizeGroceryList({ mealPlanId, userId });
  res.json({ success: true, groceryList });
});
```

## Data Model (Unchanged)

Uses existing Supabase schema from `DATABASE_SCHEMA_SUPABASE.md`:
- `recipes` - Recipe metadata with cost, category, moderation status
- `ingredients` - Aldi pricing data
- `recipe_ingredients` - Junction table with quantities
- `meal_plans` - Generated weekly plans
- `user_ratings` - User feedback
- `user_preferences` - Dietary preferences
- `moderation_queue` - Recipe approval workflow

## Key Advantages Over Manual Algorithms

| Manual Algorithm Problem | LangChain Solution |
|--------------------------|-------------------|
| ❌ Hardcoded rules break with edge cases | ✅ AI adapts to unexpected scenarios |
| ❌ Difficult to balance competing constraints | ✅ AI reasons about tradeoffs holistically |
| ❌ Adding new constraints requires code changes | ✅ Update prompts, redeploy instantly |
| ❌ No explanation for decisions | ✅ AI provides reasoning for transparency |
| ❌ Fragile unit conversion logic | ✅ AI handles conversions contextually |
| ❌ Recipe matching is brittle | ✅ AI does fuzzy matching with context |
| ❌ Hard to personalize | ✅ AI learns from user feedback over time |

## Prompt Engineering Strategy

### Meal Planning Prompt Structure

```
1. System Context: Define the AI's role and expertise
2. Constraints: List hard constraints (budget, variety rules)
3. Preferences: Soft constraints (user likes/dislikes, optimize for X)
4. Data: Provide available recipes, past meals, pantry items
5. Instructions: Step-by-step reasoning process
6. Output Format: JSON schema with required fields
```

**Example:**
```
You are an expert meal planner for budget-conscious families.

HARD CONSTRAINTS:
- Weekly budget: $75
- Must select exactly 7 recipes (one per day)
- Avoid repeating proteins 2 days in a row
- Don't use recipes from past 4 weeks: [recipe_ids]

SOFT PREFERENCES:
- User loves chicken and vegetarian meals
- User dislikes seafood
- Prioritize quick prep times (<30 min)

AVAILABLE RECIPES: [JSON array]

PANTRY ITEMS EXPIRING SOON: [JSON array]

Think step-by-step:
1. Group recipes by category and cost
2. Select a variety of proteins across the week
3. Stay under budget while maximizing value
4. Explain each choice

Return JSON: {...}
```

## Success Metrics

1. **Accuracy:** >95% of generated meal plans stay within budget
2. **Variety:** Average protein variety score >4 (out of 5 categories)
3. **User Satisfaction:** Rating >4.0 for generated plans
4. **System Reliability:** <5% error rate in plan generation
5. **Maintenance:** <10 hours per month spent on algorithm tweaks
6. **Explainability:** 100% of plans include reasoning for each recipe

## Implementation Phases

### Phase 1: Core Meal Planning Agent (Week 1)
- Install LangChain dependencies
- Implement `mealPlanningAgent.js` with structured output
- Create Supabase tools for recipe queries
- Replace broken `backend/algorithms/mealPlanGenerator.js`
- Test end-to-end meal plan generation

### Phase 2: Recipe Discovery (Week 2)
- Implement `recipeDiscoveryAgent.js` with tool calling
- Add natural language recipe search
- Integrate AI recipe generation
- Connect to moderation queue

### Phase 3: Grocery Optimization (Week 3)
- Implement `groceryOptimizerAgent.js`
- Smart ingredient consolidation
- Store layout optimization
- Pantry integration

### Phase 4: Learning & Feedback (Week 4)
- Implement memory system for user preferences
- Use rating data to adjust recipe weights
- Fine-tune prompts based on user feedback
- A/B test different prompt strategies

### Phase 5: Polish & Scale (Week 5+)
- Add streaming responses for real-time updates
- Implement caching for common queries
- Optimize token usage and cost
- Add multi-agent collaboration

## Non-Functional Requirements

- **Performance:** Meal plan generation <10 seconds (LLM latency)
- **Cost:** <$0.10 per meal plan generation (Gemini pricing)
- **Reliability:** Retry logic for LLM failures, fallback to cached plans
- **Security:** API keys in environment variables, RLS on all tables
- **Monitoring:** Log all LLM calls, track token usage, monitor error rates

## Migration Plan (from old system)

1. **Keep old algorithm temporarily** - Don't delete until LangChain version is proven
2. **Parallel testing** - Run both systems, compare outputs
3. **Gradual rollout** - Start with 10% of users, increase as confidence grows
4. **Fallback mechanism** - If LangChain fails, fall back to rule-based system
5. **Monitor metrics** - Compare budget accuracy, variety, user satisfaction
6. **Full cutover** - Once LangChain outperforms old system consistently

## Future Enhancements

- **Vector embeddings** for semantic recipe search (use Supabase pgvector)
- **Multi-agent systems** where agents collaborate (recipe agent + nutrition agent + budget agent)
- **Fine-tuned model** for Aldi-specific meal planning (future)
- **Voice interface** using LangChain's streaming capabilities
- **Image understanding** to parse recipes from photos (Gemini Vision)

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| LLM produces invalid JSON | Use StructuredOutputParser with strict schema validation |
| LLM suggests recipes not in database | Constrain output to provided recipe IDs only |
| High API costs | Cache common queries, use cheaper model (Gemini Flash) for simple tasks |
| Slow response times | Implement streaming, show progress updates |
| Hallucinated ingredient data | Always verify against Supabase, never trust raw LLM output |
| User privacy concerns | Process data ephemerally, don't send personal info to LLM |

## Documentation Structure

This file replaces:
- ❌ `.cursor/rules/meal_planning_prd.mdc` (outdated manual algorithm approach)
- ❌ `.cursor/rules/meal_planning_plan.mdc` (outdated manual workflow)

Keep:
- ✅ `docs/DATABASE_SCHEMA_SUPABASE.md` (still relevant)
- ✅ `docs/PROJECT_STRUCTURE.md` (still relevant, update backend/ section)

New docs:
- ✅ `.cursor/rules/ai_architecture_prd.mdc` (this file)
- ✅ `docs/LANGCHAIN_IMPLEMENTATION_GUIDE.md` (technical how-to)
- ✅ `docs/PROMPT_ENGINEERING_GUIDE.md` (prompt templates and best practices)

---

**Last Updated:** 2025-12-20
**Version:** 2.0 (AI-Native Architecture)
